"""
문제: 타일 채우기
수준: 골드 4
"""
# 첫번쨰풀이
# 어느정도 거의 다 풀었지만, 마지막에서 아쉽게 생각을 못했음
# 테스트로 해당 값이 나오는지 확인해보는게 좋았을듯
# 이중루프 버전
# 누적합을 이용해서도 가능
N = int(input())

if N % 2 == 1:
    print(0)
else:
    dp = [0] * (N + 1)
    dp[2] = 3
    for i in range(4, N + 1, 2):
        dp[i] = 3*dp[i - 2] + 2
        for j in range(i - 4, 0, -2):
            dp[i] += 2*(dp[j])

    print(dp[N])

# 두번쨰 풀이
# 누적합을 이용한 풀이
N = int(input())

dp = [0] * (N + 1)

if N >= 2:
    dp[2] = 3

# 누적합을 이용함 여기서는
acc = 0  # dp[2] + dp[4] + ... + dp[i-4]
for i in range(4, N + 1, 2):
    dp[i] = 3 * dp[i - 2] + 2 * acc + 2  # (+2는 dp[0]의 기여)
    acc += dp[i - 2]

print(dp[N])


# 세번쨰 풀이 (강의 풀이)
# 여기서는 dp[0] = 1로 의미를 부여했음
# 내가 처음에 dp를 짤때는 해당 n까지의 놓을 수 있는 타일의 경우의수 였음
# 그래서 dp[0] = 0 으로 생각헀었는데
# 해당 풀이로 풀때는  dp[0] = 1로 해야지 dp table 을 잘 갱신할 수 있음
# 만약 사용하지 않는 부분을 이용해서 초기값 처리를 할때는
# "의미 보다는 갱신"이 잘 되게"끔 설정하는 것이 중요
N = int(input())

dp = [0] * (N + 1)

dp[0] = 1

for n in range(2, N + 1, 2):
    dp[n] = dp[n - 2] * 3
    for i in range(n - 4, -1, -2):
        dp[n] += dp[i] * 2

print(dp[N])

